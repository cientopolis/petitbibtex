
@CONFERENCE{Miranda201857,
author={Miranda, E. and Boix, E.G. and Béra, C. and Ingalls, D.},
title={Two decades of smalltalk VM development live VM development through simulation tools},
journal={VMIL 2018 - Proceedings of the 10th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages, co-located with SPLASH 2018},
year={2018},
pages={57-66},
doi={10.1145/3281287.3281295},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85059004792&doi=10.1145%2f3281287.3281295&partnerID=40&md5=b14d43c3f2d844f8637d6aa9b00acb91},
abstract={OpenSmalltalk-VM is a virtual machine (VM) for languages in the Smalltalk family (e.g. Squeak, Pharo) which is itself written in a subset of Smalltalk that can easily be translated to C. Development is done in Smalltalk, an activity we call “Simulation”. The production VM is derived by translating the core VM code to C. As a result, two execution models coexist: simulation, where the Smalltalk code is executed on top of a Smalltalk VM, and production, where the same code is compiled to an executable through a C compiler. In this paper, we detail the VM simulation infrastructure and we report our experience developing and debugging the garbage collector and the just-in-time compiler (JIT) within it. Then, we discuss how we use the simulation infrastructure to perform analysis on the runtime, directing some design decisions we have made to tune VM performance. © 2018 Copyright held by the owner/author(s).},
document_type={Conference Paper},
source={Scopus},
}

@ARTICLE{Bouraqadi20182,
author={Bouraqadi, N. and Mason, D.},
title={Test-driven development for generated portable Javascript apps},
journal={Science of Computer Programming},
year={2018},
volume={161},
pages={2-17},
doi={10.1016/j.scico.2018.02.003},
note={cited By 1},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85044508132&doi=10.1016%2fj.scico.2018.02.003&partnerID=40&md5=a9bcb8f022f575bd864f88be518642b5},
abstract={With the advent of HTML 5, we can now develop rich web apps in Javascript that rival classical standalone apps. Nevertheless, developing in Javascript is still challenging and error prone because of the language's ambiguous semantics and quirks. In this paper, we advocate that the popular solution of using another language with better semantics and constructs is not enough. Developers should be provided with an IDE that eases the integration of Javascript libraries and enables testing an application across the many available Javascript interpreters. We introduce PharoJS,1 an infrastructure that allows Test-Driven Development (TDD) in Pharo Smalltalk of applications that ultimately run on a Javascript interpreter. PharoJS makes it possible to run interactive tests within the Pharo IDE, so as to fully exploit the debugging and development environment, while UI and libraries reside on the Javascript side. © 2018 Elsevier B.V.},
document_type={Article},
source={Scopus},
}

@ARTICLE{Costiou2018149,
author={Costiou, S. and Kerboeuf, M. and Cavarlé, G. and Plantec, A.},
title={Lub: A pattern for fine grained behavior adaptation at runtime},
journal={Science of Computer Programming},
year={2018},
volume={161},
pages={149-171},
doi={10.1016/j.scico.2017.09.006},
note={cited By 2},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85030790039&doi=10.1016%2fj.scico.2017.09.006&partnerID=40&md5=b2dc7ded6f723b1d7df0daf5a74db7da},
abstract={Autonomous systems have to evolve in complex environments and their software must adapt to various situations. Although it is common to anticipate adaptations at design time, it becomes a more complex issue when facing unpredictable contexts at runtime, especially if applications cannot be stopped. We introduce Lub, a pattern designed to extend object oriented languages with fine grained unanticipated adaptations. Lub is based on dynamic instrumentation of the lookup, and allows objects to acquire behaviors from another class than their own. A Pharo Smalltalk implementation of Lub is evaluated through a performance analysis and a running example of a fleet of drones facing unexpected GPS problems. Lub is then discussed from the unanticipated software adaptation perspective. © 2017 Elsevier B.V.},
document_type={Article},
source={Scopus},
}

@ARTICLE{Milojković2018105,
author={Milojković, N. and Béra, C. and Ghafari, M. and Nierstrasz, O.},
title={Mining inline cache data to order inferred types in dynamic languages},
journal={Science of Computer Programming},
year={2018},
volume={161},
pages={105-121},
doi={10.1016/j.scico.2017.11.003},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85034845249&doi=10.1016%2fj.scico.2017.11.003&partnerID=40&md5=f21c866d0a74c7028702f0be1e1db371},
abstract={The lack of static type information in dynamically-typed languages often poses obstacles for developers. Type inference algorithms can help, but inferring precise type information requires complex algorithms that are often slow. A simple approach that considers only the locally used interface of variables can identify potential classes for variables, but popular interfaces can generate a large number of false positives. We propose an approach called inline-cache type inference (ICTI) to augment the precision of fast and simple type inference algorithms. ICTI uses type information available in the inline caches during multiple software runs, to provide a ranked list of possible classes that most likely represent a variable's type. We evaluate ICTI through a proof-of-concept that we implement in Pharo Smalltalk. The analysis of the top-n+2 inferred types (where n is the number of recorded run-time types for a variable) for 5486 variables from four different software systems shows that ICTI produces promising results for about 75% of the variables. For more than 90% of variables, the correct run-time type is present among first six inferred types. Our ordering shows a twofold improvement when compared with the unordered basic approach, i.e., for a significant number of variables for which the basic approach offered ambiguous results, ICTI was able to promote the correct type to the top of the list. © 2017 Elsevier B.V.},
document_type={Article},
source={Scopus},
}

@ARTICLE{Cavarlé201818,
author={Cavarlé, G. and Plantec, A. and Costiou, S. and Ribaud, V.},
title={A feature-oriented model-driven engineering approach for the early validation of feature-based applications},
journal={Science of Computer Programming},
year={2018},
volume={161},
pages={18-33},
doi={10.1016/j.scico.2018.01.001},
note={cited By 1},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85040776931&doi=10.1016%2fj.scico.2018.01.001&partnerID=40&md5=7f216f768616a1af68b9cdae7d1c17fa},
abstract={The software industry has to offer increasingly individualized software for a large number of platforms. In a constantly evolving technical context, the appropriateness and the profitableness of a software has to be ensured earlier, before most of the costs have been incurred and before most of the risks have been taken. Feature-Oriented Model-Driven Development (FOMDD) is a promising paradigm to tackle the issue of developing software variants when multiple platforms are targeted. However, because of its model-driven fundament, FOMDD suffers from limited capabilities regarding model execution and early validation. In this paper, we present CrossFabrik, an approach for the design and the early functional validation of feature-based applications. This approach allows the live debugging and editing of the underlying models during a simulation without being forced to stop and restart a validation process. Such an approach relies on the reflective capability of the development environment. An implementation of our approach within Pharo is also presented. © 2018 Elsevier B.V.},
document_type={Article},
source={Scopus},
}

@ARTICLE{Sawant20182158,
author={Sawant, A.A. and Robbes, R. and Bacchelli, A.},
title={On the reaction to deprecation of clients of 4 + 1 popular Java APIs and the JDK},
journal={Empirical Software Engineering},
year={2018},
volume={23},
number={4},
pages={2158-2197},
doi={10.1007/s10664-017-9554-9},
note={cited By 3},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85031416657&doi=10.1007%2fs10664-017-9554-9&partnerID=40&md5=00e478fbaaf19937c9e60b62e5bd0d5d},
abstract={Application Programming Interfaces (APIs) are a tremendous resource—that is, when they are stable. Several studies have shown that this is unfortunately not the case. Of those, a large-scale study of API changes in the Pharo Smalltalk ecosystem documented several findings about API deprecations and their impact on API clients. We extend this study, by analyzing clients of both popular third-party Java APIs and the JDK API. This results in a dataset consisting of more than 25,000 clients of five popular Java APIs on GitHub, and 60 clients of the JDK API from Maven Central. This work addresses several shortcomings of the previous study, namely: a study of several distinct API clients in a popular, statically-typed language, with more accurate version information. We compare and contrast our findings with the previous study and highlight new ones, particularly on the API client update practices and the startling similarities between reaction behavior in Smalltalk and Java. We make a comparison between reaction behavior for third-party APIs and JDK APIs, given that language APIs are a peculiar case in terms of wide-spread usage, documentation, and support from IDEs. Furthermore, we investigate the connection between reaction patterns of a client and the deprecation policy adopted by the API used. © 2017, The Author(s).},
document_type={Article},
source={Scopus},
}

@CONFERENCE{Costiou2018144,
author={Costiou, S. and Kerboeuf, M. and Plantec, A. and Denker, M.},
title={Collectors},
journal={ACM International Conference Proceeding Series},
year={2018},
volume={Part F137691},
pages={144-152},
doi={10.1145/3191697.3214335},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85053662134&doi=10.1145%2f3191697.3214335&partnerID=40&md5=f8e5d2f1b7fd11a0b172e968d69effb2},
abstract={Observing and modifying object-oriented programs often means interacting with objects. At runtime, it can be a complex task to identify those objects due to the live state of the program. Some objects may exist for only a very limited period of time, others can be hardly reachable because they are never stored in variables. To address this problem we present Collectors. They are dedicated objects which can collect objects of interest at runtime and present them to the developer. Collectors are non-intrusive, removable code instrumentations. They can be dynamically specified and injected at runtime. They expose an API to allow their specification and the access to the collected objects. In this paper, we present an implementation of Collectors in Pharo, a Smalltalk dialect. We enrich the Pharo programming and debugging environment with tools that support the Collectors API. We illustrate the use of these API and tools through the collection and the logging of specific objects in a running IOT application. © 2018 Copyright held by the owner/author(s).},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Grover2017,
author={Grover, J. and Papoulias, N. and Stinckwich, S. and Bommel, P.},
title={Pragmatic insights: Live UIs for agent-based modelling in pharo},
journal={IWST 2017 - Proceedings of the 12th International Workshop on Smalltalk Technologies, in conjunction with the 25th International Smalltalk Joint Conference},
year={2017},
doi={10.1145/3139903.3139915},
art_number={a10},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85040180835&doi=10.1145%2f3139903.3139915&partnerID=40&md5=3d9e88c1e18288b379fac74fc97d1b93},
abstract={Object-oriented programming has had a long-standing history with simulation systems in terms of human-computer interaction [1] dating back to Simula and early versions of Smalltalk-72 and Smalltalk-76. These frameworks were based on discrete, event-based simulations as revealed by the classic simulation examples of Smalltalk-80 Blue-book [2]. Nevertheless present time trends have pivoted towards agent-based modelling and abstractions, with systems like NetLogo capturing a sizeable following and heed. Two of the widely known agent-based modelling (ABM) platforms in Smalltalk (MobiDyC and CORMAS) have recently begun experimenting with porting their systems to Pharo. The rationale behind this choice is to allow modern re-imagination of the platforms that can take advantage of developments in: agile visualization, moldable tools, domain-specific languages (DSLs) and so on. This work focuses on the salient user interface component of these platforms, namely the spatial interface, which empowers a user to visualize the evolution of the system through time. We start with a concise analysis of the state-of-the-art for spatial interfaces and their platforms (MobiDyC, NetLogo, GAMA and CORMAS), scrutinizing in terms of programming flexibility, extensibility, portability, scalability, and interaction. Subsequently we highlight our on-going efforts in building an open-source extension for CORMAS’ spatial interface in Pharo. In closing, we detail the pragmatic experience gained in the course of our work and present future perspectives. Copyright © 2017 ACM.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Zaytsev2017,
author={Zaytsev, O. and Papoulias, N. and Stinckwich, S.},
title={Towards exploratory data analysis for pharo},
journal={IWST 2017 - Proceedings of the 12th International Workshop on Smalltalk Technologies, in conjunction with the 25th International Smalltalk Joint Conference},
year={2017},
doi={10.1145/3139903.3139918},
art_number={a12},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85040178753&doi=10.1145%2f3139903.3139918&partnerID=40&md5=c9e92e0ac7f02b8ca3bf9901c1168375},
abstract={Data analysis and visualizations techniques (such as split-apply-combine) make extensive use of associative tabular data-structures that are cumbersome to use with common aggregation APIs (for arrays, lists or dictionaries). In these cases a fluent API for querying associative tabular data (like the ones provided by Pandas, Mathematica or LINQ) is more appropriate for interactive exploration environments. In Smalltalk despite the fact that many important analysis tools are already present (for e.g., in the PolyMath library), we are still missing this essential part of the data science toolkit. These specialized data structures for tabular datasets can provide us with a simple and powerful API for summarizing, cleaning, and manipulating a wealth of data-sources that are currently cumbersome to use. In this paper we introduce the DataFrame and DataSeries collections - that are specifically designed for working with structured data. We demonstrate how these tools can be used for descriptive statistics and Exploratory Data Analysis (EDA) - the critical first step of data analysis which allows us to get the summary of a dataset, detect mistakes, determine the relations, and select the appropriate model for further confirmatory analysis. We then detail the implementation trade-o s that we are currently facing in our implementation for Pharo and discuss future perspectives. © 2017 Association for Computing Machinery.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{NoAuthor2017,
title={IWST 2017 - Proceedings of the 12th International Workshop on Smalltalk Technologies, in conjunction with the 25th International Smalltalk Joint Conference},
journal={IWST 2017 - Proceedings of the 12th International Workshop on Smalltalk Technologies, in conjunction with the 25th International Smalltalk Joint Conference},
year={2017},
page_count={117},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85040161823&partnerID=40&md5=71cf911bff0938ae8a29f61b923de74e},
abstract={The proceedings contain 14 papers. The topics discussed include: solidity parsing using SmaCC: challenges and irregularities; towards modularity in live visual modeling: a case-study with OpenPonk and Kendrick; usage of tests in an open-source community; analysis and exploration for new generation debuggers; a detailed VM profiler for the cog VM; ad-hoc runtime object structure visualizations with metalinks; debugging cyber physical systems with Pharo: an experience report; first-class undefined classes for Pharo; Pragmatic insights: live uis for agent-based modeling in Pharo; Pharo git thermite: a visual tool for deciding to weld a pull request; towards exploratory data analysis for Pharo; and Renraku - the one static analysis model to rule them all.},
document_type={Conference Review},
source={Scopus},
}

@CONFERENCE{Milojkovic201777,
author={Milojkovic, N. and Ghafari, M. and Nierstrasz, O.},
title={Exploiting Type Hints in Method Argument Names to Improve Lightweight Type Inference},
journal={IEEE International Conference on Program Comprehension},
year={2017},
pages={77-87},
doi={10.1109/ICPC.2017.33},
art_number={7961506},
note={cited By 3},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85025134739&doi=10.1109%2fICPC.2017.33&partnerID=40&md5=718ff6495077e78b4ec254a4f5fc3d80},
abstract={The lack of static type information is one of the main obstacles to program comprehension in dynamically-typed languages. While static type inference algorithms try to remedy this problem, they usually suffer from the problem of false positives or false negatives. In order to partially compensate for the lack of static type information, a common practice in dynamically-typed languages is to name or annotate method arguments in such a way that they reveal their expected type, e.g., aString, anInt, or string: String. Recent studies confirmed that these type annotations are indeed frequently used by developers in dynamically-typed languages. We propose a lightweight heuristic that uses these hints from method argument names to augment the performance of a static type inference algorithm. The evaluation through a proof-of-concept prototype implemented in Pharo Smalltalk shows that the augmented algorithm outperforms the basic algorithm, and correctly infers types for 81% more method arguments. © 2017 IEEE.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Sawant2017400,
author={Sawant, A.A. and Robbes, R. and Bacchelli, A.},
title={On the reaction to deprecation of 25,357 clients of 4+1 popular Java APIs},
journal={Proceedings - 2016 IEEE International Conference on Software Maintenance and Evolution, ICSME 2016},
year={2017},
pages={400-410},
doi={10.1109/ICSME.2016.64},
art_number={7816485},
note={cited By 8},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85013130630&doi=10.1109%2fICSME.2016.64&partnerID=40&md5=6a40d40b4dfae803da9ac4bbb526bea7},
abstract={Application Programming Interfaces (APIs) are a tremendous resource-that is, when they are stable. Several studies have shown that this is unfortunately not the case. Of those, a large-scale study of API changes in the Pharo Smalltalk ecosystem documented several findings about API deprecations and their impact on API clients. We conduct a partial replication of this study, considering more than 25,000 clients of five popular Java APIs on GitHub. This work addresses several shortcomings of the previous study, namely: a study of several distinct API clients in a popular, statically-typed language, with more accurate version information. We compare and contrast our findings with the previous study and highlight new ones, particularly on the API client update practices and the startling similarities between reaction behavior in Smalltalk and Java. © 2016 IEEE.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Milojkovíc201643,
author={Milojkovíc, N. and Nierstrasz, O.},
title={Exploring cheap type inference heuristics in dynamically typed languages},
journal={Onward! 2016 - Proceedings of the 2016 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
year={2016},
pages={43-56},
doi={10.1145/2986012.2986017},
note={cited By 4},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84997221705&doi=10.1145%2f2986012.2986017&partnerID=40&md5=77bb978e8981a223dc5237d055c268ba},
abstract={Although dynamically typed languages allow developers to be more productive in writing source code, their lack of information about types of variables is one of the main obstacles during program comprehension. Static type information helps developers to decrease software maintenance time. Inference of types of variables requires complex algorithms to avoid false positives or negatives. Their main aim is to shorten the list of possible types for a variable. We have developed a couple of cheap heuristics that use easily accessible information about the presence of each class in the available source code to promote the correct type towards the top of the list of possible types for a variable. Our evaluation of a proof-of-concept prototype, implemented in Pharo Smalltalk, shows that both for domainspecific types and standard libraries these heuristics tend to work well. The evaluated heuristics prove to be reasonably precise, promoting the correct types of a variable towards the top of the list in 50.67% up to 89.09% of cases on average, depending on the applied heuristic. The heuristic that has proved to be the best was compared with one existing type inference algorithm and the best heuristic yields significantly better results with less effort. © 2016 ACM.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Oda2016,
author={Oda, T. and Araki, K. and Larsen, P.G.},
title={ViennaTalk and assertch: Building lightweight formal methods environments on pharo 4},
journal={IWST 2016 - Proceedings of the 11th International Workshop on Smalltalk Technologies, in conjunction with the 24th International Smalltalk Joint Conference},
year={2016},
doi={10.1145/2991041.2991045},
note={cited By 2},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85006760116&doi=10.1145%2f2991041.2991045&partnerID=40&md5=51ba5008a8d8ae6ec1286e2ada890710},
abstract={It is possible to make Integrated Development Environments supporting formal methods that can be as flexible as the support for dynamic programming languages. This paper contributes with a demonstration employing different support environments for the Vienna Development Method Specification Language (VDMSL) and design by contract for visual programming language. This includes ViennaTalk developed on top of Pharo 4 providing Smalltalk-styled LIVE browsers, VDM-SL interpreters, Smalltalk code generators, UI prototyping environments and a prototypeWeb API server to enable rigorous and flexible modeling during exploratory phases of software development. ViennaTalk uses the Slot mechanism in Pharo to test invariant assertions on instance variables in Smalltalk objects generated from VDM-SL specifications. In addition, we present a plugin named Assertch for Phratch, a scratch-clone visual programming environment on top of Pharo 4, that provides assertion blocks for designing and debugging a series of blocks. Both ViennaTalk and Assertch combine flexible live modeling or coding while still supporting rigorous checking. ViennaTalk has been evaluated by experienced professional engineers of VDM-SL while Assertch has been evaluated by undergraduate students of computer science. ViennaTalk and Assertch both demonstrate that Pharo and its contemporary features support rigorous modeling in formal specification languages as well as flexible prototyping in Smalltalk. ©2016 held by owner/author(s).},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Salgado2016,
author={Salgado, R. and Ducasse, S.},
title={Lowcode: Extending pharo with c types to improve performance},
journal={IWST 2016 - Proceedings of the 11th International Workshop on Smalltalk Technologies, in conjunction with the 24th International Smalltalk Joint Conference},
year={2016},
doi={10.1145/2991041.2991064},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85006817636&doi=10.1145%2f2991041.2991064&partnerID=40&md5=47a7166788fc1aede954bd52a5fdf557},
abstract={The highly dynamic nature of Smalltalk provides a high degree of exibility, but at the expense of performance. On the other hand, static system programming languages such as C are really fast, but less exible and harder to use than Smalltalk. Our hypothesis is that by mixing the concepts of these two worlds in a single programming environment, we are able to have improved performance and a high level of exibility at the same time. In this work we extend Pharo by adding a type system that provides the native data types present in C along with the dynamic object type. We extend Pharo compiler and virtual machine to use our type system by add custom bytecode instructions for dealing with native data. With our approach we obtain a performance improvement on average between two and five times faster for numerical computations using single precision oating point arithmetic in Smalltalk.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{NoAuthor2016,
title={IWST 2016 - Proceedings of the 11th International Workshop on Smalltalk Technologies, in conjunction with the 24th International Smalltalk Joint Conference},
journal={IWST 2016 - Proceedings of the 11th International Workshop on Smalltalk Technologies, in conjunction with the 24th International Smalltalk Joint Conference},
year={2016},
page_count={216},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85006797194&partnerID=40&md5=d6d55b1928af79a6f0db0073c0dfc672},
abstract={The proceedings contain 25 papers. The topics discussed include: CommunityExplorer: a framework for visualizing collaboration networks; SmalltalkCI: a continuous integration framework for smalltalk projects; ViennaTalk and Assertch: building lightweight formal methods environments on Pharo; when quality-assistant meets Pharo: enforced code critiques motivate more valuable rules; inferring types by mining class usage frequency from inline caches; the object repository - pulling objects out of the ecosystem; dynamically composing collection operations through collection promises; Pragmas: literal messages as powerful method annotations; mocks, proxies, and transpilation as development strategies for web development; clustering technique for conceptual clusters; prototyping software product lines analysis with Pharo; Lub: a DSL for dynamic context oriented programming; the OpenPonk modeling platform; dynamic round-trip engineering in the context of FOMDD; Phorms: pattern combinator library for Pharo; test selection with Moose In industry - impact of granularity; a promising approach for debugging remote promises; and chromatic and harmonic scales for intuitive sonographic compositions.},
document_type={Conference Review},
source={Scopus},
}

@CONFERENCE{Milojkovíc2016,
author={Milojkovíc, N. and Béra, C. and Ghafari, M. and Nierstrasz, O.},
title={Inferring types by mining class usage frequency from inline caches},
journal={IWST 2016 - Proceedings of the 11th International Workshop on Smalltalk Technologies, in conjunction with the 24th International Smalltalk Joint Conference},
year={2016},
doi={10.1145/2991041.2991047},
note={cited By 3},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85006802839&doi=10.1145%2f2991041.2991047&partnerID=40&md5=0a255487ddb1b2761b369306a4aa9f65},
abstract={Dynamically typed languages allow developers to write more expressive source code, but their lack of static information about types of variables increases the complexity of a program. Static type information about types of variables facilitates program comprehension and maintenance. Simple type inference algorithms suffer from the problem of false positives or negatives, thus complex approaches are required to avoid this problem. We propose a simple heuristic that uses easily accessible run-Time information about the usage of each class as a receiver type for a message send. This frequency serves as a proxy for the likelihood that a run-Time type of the variable is that class and it is used to promote the correct type towards the top of the list of possible types for a variable. Our evaluation of a proof-of-concept prototype implemented in Pharo Smalltalk shows that our heuristic is reasonably precise to detect correct types on average in 65.92% to 82.83% of cases. ©2016 held by owner/author(s).},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Cavarlé2016,
author={Cavarlé, G. and Plantec, A. and Costiou, S. and Ribaud, V.},
title={Dynamic round-Trip engineering in the context of FOMDD},
journal={IWST 2016 - Proceedings of the 11th International Workshop on Smalltalk Technologies, in conjunction with the 24th International Smalltalk Joint Conference},
year={2016},
doi={10.1145/2991041.2991056},
note={cited By 1},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85006830324&doi=10.1145%2f2991041.2991056&partnerID=40&md5=b33913c397f1478125134b11194d4424},
abstract={In the context of Feature-Oriented Model-Driven Development, round-Trip engineering remains challenging because of the one-To-many relationship that exists between a source model and its implementation parts. In this paper, we present CrossFabrik, an approach that allows round-Trip engineering with dynamic assessment of generated implementations. Such an approach relies on the reflective capability of the development environment. An implementation of our approach within Pharo is also presented. © 2016 held by owner/author(s).},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Béra2016,
author={Béra, C.},
title={A low overhead per object write barrier for the cog VM},
journal={IWST 2016 - Proceedings of the 11th International Workshop on Smalltalk Technologies, in conjunction with the 24th International Smalltalk Joint Conference},
year={2016},
doi={10.1145/2991041.2991063},
note={cited By 1},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85006788916&doi=10.1145%2f2991041.2991063&partnerID=40&md5=9af895c8be3d3a37137adef74694f595},
abstract={In several Smalltalk implementations, a program can mark any object as read-only (unfortunately incorrectly sometimes miscalled immutable). Such read-only objects cannot be mutated unless the program explicitly revert them to a writable state. This feature, called write barrier, may induce noticeable overhead if not implemented carefully, both in memory footprint and execution time. In this paper I discuss the recent addition of the write barrier in the Cog virtual machine and the support introduced in the Pharo 6 image. I detail specific aspects of the implementation that allows, according to multiple evaluations presented in the paper, to have such a feature with little to no overhead. © 2016 held by owner/author(s).},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Merino2016,
author={Merino, L. and Seliner, D. and Ghafari, M. and Nierstrasz, O.},
title={CommunityExplorer: A framework for visualizing collaboration networks},
journal={IWST 2016 - Proceedings of the 11th International Workshop on Smalltalk Technologies, in conjunction with the 24th International Smalltalk Joint Conference},
year={2016},
doi={10.1145/2991041.2991043},
note={cited By 4},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85006827358&doi=10.1145%2f2991041.2991043&partnerID=40&md5=0576827091d75904a6d7e473e448f7a6},
abstract={Understanding the network of collaborations, identifying the key players, potential future collaborators, and trends in the field are very important to carry out a project successfully. In this paper, we present CommunityExplorer, a visualization framework that facilitates presenting, exploring, and understanding the network of collaborations at once. The framework performs data extraction, parsing, and modeling automatically. It is easy to adopt and utilizes a bigraph visualization that scales well.We demonstrate the advantage of CommunityExplorer to identify the collaboration of authors on 346 and 104 research papers published in SOTFVIS/VISSOFT and IWST communities respectively.We found that even though SOFTVIS/VISSOFT has more contributors, IWST exhibits more collaboration.We discovered that contributors in IWST are more resilient than those in SOFTVIS/VISSOFT, which are more volatile.Moreover, collaboration in IWST is concentrated in a single large group, while in SOFTVIS/VISSOFT it is spread amongmany tiny groups and a few medium-sized ones. © Copyright 2016 held by owner/author(s).},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Oliveira2015546,
author={Oliveira, P. and Valente, M.T. and Bergel, A. and Serebrenik, A.},
title={Validating metric thresholds with developers: An early result},
journal={2015 IEEE 31st International Conference on Software Maintenance and Evolution, ICSME 2015 - Proceedings},
year={2015},
pages={546-550},
doi={10.1109/ICSM.2015.7332511},
art_number={7332511},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84961666313&doi=10.1109%2fICSM.2015.7332511&partnerID=40&md5=54498dad04d368413a0db3320eb70dd5},
abstract={Thresholds are essential for promoting source code metrics as an effective instrument to control the internal quality of software applications. However, little is known about the relation between software quality as identified by metric thresholds and as perceived by real developers. In this paper, we report the first results of a study designed to validate a technique that extracts relative metric thresholds from benchmark data. We use this technique to extract thresholds from a benchmark of 79 Pharo/Smalltalk applications, which are validated with five experts and 25 developers. Our preliminary results indicate that good quality applications- as cited by experts- respect metric thresholds. In contrast, we observed that noncompliant applications are not largely viewed as requiring more effort to maintain than other applications. © 2015 IEEE.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Polito2015183,
author={Polito, G. and Ducasse, S. and Bouraqadi, N. and Fabresse, L.},
title={A bootstrapping infrastructure to build and extend pharo-like languages},
journal={Onward! 2015 - Proceedings of the 2015 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software, Part of SPLASH 2015},
year={2015},
pages={183-196},
doi={10.1145/2814228.2814236},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84956702913&doi=10.1145%2f2814228.2814236&partnerID=40&md5=6fd39bc1eb63342ddd649101c0b383c1},
abstract={Bootstrapping is well known in the context of compilers, where a bootstrapped compiler can compile its own source code. Bootstrapping is a beneficial engineering practice because it raises the level of abstraction of a program making it easier to understand, optimize, evolve, etc. Bootstrapping a reflective object-oriented language is however more challenging, as we need also to initialize the runtime of the language with its initial objects and classes besides writing its compiler. In this paper, we present a novel bootstrapping infrastructure for Pharo-like languages that allows us to easily extend and modify such languages. Our bootstrapping process relies on a first-class runtime. A first-class runtime is a meta-object that represents a program's runtime and provides a MOP to easily load code into it and manipulate its objects. It decouples the virtual machine (VM) and language concerns by introducing a clear VM-language interface. Using this process, we show how we succeeded to bootstrap a Smalltalk-based language named Candle and then extend it with traits in less than 250 lines of high-level Smalltalk code. We also show how we can bootstrap with minimal effort two other languages (Pharo and MetaTalk) with similar execution semantics but different object models. © 2015 ACM.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Sang2015,
author={Sang, L.E.X. and Lagadec, L. and Fabresse, L. and Laval, J. and Bouraqadi, N.},
title={A meta model supporting both hardware and smalltalk-based execution of FPGA circuits},
journal={IWST 2015 - Proceedings of the 10th International Workshop on Smalltalk Technologies, in conjunction with the 23rd International Smalltalk Joint Conference},
year={2015},
doi={10.1145/2811237.2811296},
note={cited By 1},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84964284421&doi=10.1145%2f2811237.2811296&partnerID=40&md5=5c6cd9581e61af017c7779ae99e17d4e},
abstract={High level synthesis (HLS) refers to an automated process that creates a digital hardware from an algorithmic description of some computation. From the perspective of Smalltalk, this process consists of converting code from the oriented object level to the register transfer level (RTL), that supports direct compilation to the hardware level. In this paper, we present first steps to achieve this process. We introduce a Smalltalk-based meta-model that allows expressing descriptions (i.e. models) of digital circuits. These descriptions can be materialized as Smalltalk code. A such circuit description can be run on top of the Smalltalk VM, simulating the parallelism intrinsic of hardware. Alternatively, it can be compiled into a binary representation directly transferable to FPGA chips, which can run and exchange data with Smalltalk objects. Copyright © 2015 ACM.},
document_type={Conference Paper},
source={Scopus},
}

@ARTICLE{UquillasGómez2015376,
author={Uquillas Gómez, V. and Ducasse, S. and D'Hondt, T.},
title={Visually characterizing source code changes},
journal={Science of Computer Programming},
year={2015},
volume={98},
number={P3},
pages={376-393},
doi={10.1016/j.scico.2013.08.002},
note={cited By 9},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84919463542&doi=10.1016%2fj.scico.2013.08.002&partnerID=40&md5=225695241359f319e86a03cf602b40da},
abstract={Revision Control Systems (e.g., SVN, Git, Mercurial) include automatic and advanced merging algorithms that help developers to merge their modifications with development repositories. While these systems can help to textually detect conflicts, they do not help to identify the semantic consequences of a change. Unfortunately, there is little support to help release masters (integrators) to take decisions about the integration of changes into the system release. Most of the time, the release master needs to read all the modified code, check the diffs to build an idea of a change, and dig for details from related unchanged code to understand the context and potential impact of some changes. As a result, such a task can be overwhelming. In this article we present a visualization tool to support integrators of object-oriented programs in comprehending changes. Our approach named Torch characterizes changes based on structural information, authors and symbolic information. It mixes text-based diff information with visual representation and metrics characterizing the changes. The current implementation of our approach analyses Smalltalk programs, and thus we describe our experiments applying it to Pharo, a large open-source system. We also report on the evaluations of our approach by release masters and developers of several open-source projects. © 2013 Elsevier B.V. All rights reserved.},
document_type={Article},
source={Scopus},
}

@ARTICLE{MartinezPeck2015339,
author={Martinez Peck, M. and Bouraqadi, N. and Fabresse, L. and Denker, M. and Teruel, C.},
title={Ghost: A uniform and general-purpose proxy implementation},
journal={Science of Computer Programming},
year={2015},
volume={98},
number={P3},
pages={339-359},
doi={10.1016/j.scico.2014.05.015},
note={cited By 5},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84919463649&doi=10.1016%2fj.scico.2014.05.015&partnerID=40&md5=a9d5919c052bba22a7604b2a6b503e62},
abstract={A proxy object is a surrogate or placeholder that controls access to another target object. Proxy objects are a widely used solution for different scenarios such as remote method invocation, future objects, behavioral reflection, object databases, inter-language communications and bindings, access control, lazy or parallel evaluation, security, among others. Most proxy implementations support proxies for regular objects but are unable to create proxies for objects with an important role in the runtime infrastructure such as classes or methods. Proxies can be complex to install, they can have a significant overhead, they can be limited to certain kind of classes, etc. Moreover, proxy implementations are often not stratified and there is no clear separation between proxies (the objects intercepting messages) and handlers (the objects handling interceptions). In this paper, we present Ghost: a uniform and general-purpose proxy implementation for the Pharo programming language. Ghost provides low memory consuming proxies for regular objects as well as for classes and methods. When a proxy takes the place of a class, it intercepts both the messages received by the class and the lookup of methods for messages received by its instances. Similarly, if a proxy takes the place of a method, then the method execution is intercepted too. © 2014 Elsevier B.V. All rights reserved.},
document_type={Article},
source={Scopus},
}

@ARTICLE{Fabry2014393,
author={Fabry, J. and Galdames, D.},
title={PHANtom: A modern aspect language for Pharo Smalltalk},
journal={Software - Practice and Experience},
year={2014},
volume={44},
number={4},
pages={393-412},
doi={10.1002/spe.2117},
note={cited By 2},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84897625261&doi=10.1002%2fspe.2117&partnerID=40&md5=9798acdd02c5be7205f7a9b25a60b30e},
abstract={In the context of our research on Aspect-Oriented Programming, we have a need for a modern and powerful aspect language for Smalltalk. Current aspect languages for Smalltalk however fall short on various points. To address this deficit, we elected to design and build PHANtom: a modern aspect language for Pharo Smalltalk. PHANtom is designed to be an aspect language in the spirit of Smalltalk: dynamic, simple, and powerful. PHANtom is a modern aspect language because it incorporates the best features of languages that precede it, includes recent research results in aspect interactions and reentrancy control, and is designed from the onset to be optimized and compiled where possible. In this paper, we present the latest version of the language and give examples and patterns of use. Copyright © 2012 John Wiley & Sons, Ltd. Copyright © 2012 John Wiley & Sons, Ltd.},
document_type={Conference Paper},
source={Scopus},
}

@ARTICLE{Dias2014433,
author={Dias, M. and Peck, M.M. and Ducasse, S. and Arévalo, G.},
title={Fuel: A fast general purpose object graph serializer},
journal={Software - Practice and Experience},
year={2014},
volume={44},
number={4},
pages={433-453},
doi={10.1002/spe.2136},
note={cited By 4},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84897620098&doi=10.1002%2fspe.2136&partnerID=40&md5=1fde9a966fbeb5ee7084307ca6cf913a},
abstract={Because objects need to be stored and reloaded on different environments, serializing object graphs is a very important activity. There is a plethora of serialization frameworks with different requirements and design trade-offs. Most of them are based on recursive parsing of the object graphs, an approach which often is too slow. In addition, most of them prioritize a language-agnostic format instead of speed and language-specific object serialization. For the same reason, such serializers usually do not support features such as class-shape changes, global references or executing pre and post load actions. Looking for speed, some frameworks are partially implemented at Virtual Machine (VM) level, hampering code portability and making them difficult to understand, maintain and extend.In this paper, we present Fuel, a general-purpose object serializer based on these principles: (1) speed, through a compact binary format and a pickling algorithm which invests time in serialization for obtaining the best performance on materialization; (2) good object-oriented design, without special help at VM; and (3) serialize any object, thus have a full-featured language-specific format.We implement and validate this approach in Pharo, where we demonstrate that Fuel is faster than other serializers, even those with special VM support. The extensibility of Fuel made possible to successfully serialize various objects: classes in Newspeak, debugger stacks, and full content management system object graphs. Copyright © 2012 John Wiley & Sons, Ltd. Copyright © 2012 John Wiley & Sons, Ltd.},
document_type={Conference Paper},
source={Scopus},
}

@ARTICLE{Polito2014141,
author={Polito, G. and Ducasse, S. and Fabresse, L. and Bouraqadi, N. and Van Ryseghem, B.},
title={Bootstrapping reflective systems: The case of Pharo},
journal={Science of Computer Programming},
year={2014},
volume={96},
number={P1},
pages={141-155},
doi={10.1016/j.scico.2013.10.008},
note={cited By 3},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84908225869&doi=10.1016%2fj.scico.2013.10.008&partnerID=40&md5=a0c2ec95034586380399c07d985f5fc0},
abstract={Bootstrapping is a technique commonly known by its usage in language definition by the introduction of a compiler written in the same language it compiles. This process is important to understand and modify the definition of a given language using the same language, taking benefit of the abstractions and expression power it provides. A bootstrap, then, supports the evolution of a language. However, the infrastructure of reflective systems like Smalltalk includes, in addition to a compiler, an environment with several self-references. A reflective system bootstrap should consider all its infrastructural components. In this paper, we propose a definition of bootstrap for object-oriented reflective systems, we describe the architecture and components it should contain and we analyze the challenges it has to overcome. Finally, we present a reference bootstrap process for a reflective system and Hazelnut, its implementation for bootstrapping the Pharo Smalltalk-inspired system. © 2014 Elsevier B.V. All rights reserved.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Lozano201449,
author={Lozano, A. and Arévalo, G. and Mens, K.},
title={A critique on code critics},
journal={CEUR Workshop Proceedings},
year={2014},
volume={1354},
pages={49-59},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84928780057&partnerID=40&md5=96bcf83c8830593700fb3ab480406e99},
abstract={Code critics are a recommendation facility of the Pharo Smalltalk IDE. They signal controversial implementation choices such as code smells at class and method level. They aim to promote the use of good and standard coding idioms for increased performance or a better use of object-oriented constructs. This paper studies relations among code critics by analyzing co-occurrences of code critics detected on the Moose system, a large and mature Smalltalk application. Based upon this analysis, we present a critique on code critics, as a first step towards an improved grouping of code critics that identifies issues at a higher level of abstraction, by combining lower-level critics that tend to co-occur, as well as improvements in the definition of the individual critics.},
document_type={Conference Paper},
source={Scopus},
}

@ARTICLE{Bergel201486,
author={Bergel, A. and Peña, V.},
title={Increasing test coverage with Hapao},
journal={Science of Computer Programming},
year={2014},
volume={79},
pages={86-100},
doi={10.1016/j.scico.2012.04.006},
note={cited By 7},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84885588221&doi=10.1016%2fj.scico.2012.04.006&partnerID=40&md5=2cadfe26ffbfd7a815673e03236c8786},
abstract={Test coverage is about assessing the relevance of unit tests against the tested application. It is widely acknowledged that software with a "good" test coverage is more robust against unanticipated execution, thus lowering the maintenance cost. However, ensuring good quality coverage is challenging, especially since most of the available test coverage tools do not discriminate between software components that require "strong" coverage from the components that require less attention from the unit tests. Hapao is an innovative test coverage tool, implemented in the Pharo Smalltalk programming language. It employs an effective and intuitive graphical representation to visually assess the quality of the coverage. A combination of appropriate metrics and relations visually shape methods and classes, which indicates to the programmer whether more effort on testing is required. This paper presents the important features of Hapao by illustrating its application on an open source software. © 2011 Elsevier B.V. All rights reserved.},
document_type={Article},
source={Scopus},
}

@CONFERENCE{Spasojević2014,
author={Spasojević, B. and Lungu, M. and Nierstrasz, O.},
title={Towards faster method search through static ecosystem analysis},
journal={ACM International Conference Proceeding Series},
year={2014},
doi={10.1145/2642803.2642814},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84907381214&doi=10.1145%2f2642803.2642814&partnerID=40&md5=5e29ba504fa17fa47e17193ac50aa16a},
abstract={Software developers are often unsure of the exact name of the method they need to use to invoke the desired behavior in a given context. This results in a process of searching for the correct method name in documentation, which can be lengthy and distracting to the developer. We can decrease the method search time by enhancing the documentation of a class with the most frequently used methods. Usage frequency data for methods is gathered by analyzing other projects from the same ecosystem - written in the same language and sharing dependencies. We implemented a proof of concept of the approach for Pharo Smalltalk and Java. In Pharo Smalltalk, methods are commonly searched for using a code browser tool called "Nautilus", and in Java using a web browser displaying HTML based documentation - Javadoc. We developed plugins for both browsers and gathered method usage data from open source projects, in order to increase developer productivity by reducing method search time. A small initial evaluation has been conducted showing promising results in improving developer productivity. © 2014 ACM.},
document_type={Conference Paper},
source={Scopus},
}

@ARTICLE{VanRyseghem201434,
author={Van Ryseghem, B. and Ducasse, S. and Fabry, J.},
title={Seamless composition and reuse of customizable user interfaces with Spec},
journal={Science of Computer Programming},
year={2014},
volume={96},
number={P1},
pages={34-51},
doi={10.1016/j.scico.2013.11.035},
note={cited By 5},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84908251358&doi=10.1016%2fj.scico.2013.11.035&partnerID=40&md5=58628ca21e4a26b8655971cfcb871d0f},
abstract={Implementing UIs is often a tedious task. To address this, UI Builders have been proposed to support the description of widgets, their location, and their logic. A missing aspect of UI Builders is however the ability to reuse and compose widget logic. In our experience, this leads to a significant amount of duplication in UI code. To address this issue, we built Spec: a UIBuilder for Pharo with a focus on reuse. With Spec, widget properties are defined declaratively and attached to specific classes known as composable classes. A composable class defines its own widget description as well as the model-widget bridge and widget interaction logic. This paper presents Spec, showing how it enables seamless reuse of widgets and how these can be customized. After presenting Spec and its implementation, we discuss how its use in Pharo 2.0 has cut in half the amount of lines of code of six of its tools, mostly through reuse. This shows that Spec meets its goals of allowing reuse and composition of widget logic. © 2014 Elsevier B.V. All rights reserved.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Minelli2014276,
author={Minelli, R. and Mocci, A. and Lanza, M. and Kobayashi, T.},
title={Quantifying program comprehension with interaction data},
journal={Proceedings - International Conference on Quality Software},
year={2014},
pages={276-285},
doi={10.1109/QSIC.2014.11},
art_number={6958415},
note={cited By 16},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84912093470&doi=10.1109%2fQSIC.2014.11&partnerID=40&md5=9300e5a2f9e8157f6045b899a3032dbe},
abstract={It is common knowledge that program comprehension takes up a substantial part of software development. This 'urban legend' is based on work that dates back decades, which throws up the question whether the advances in software development tools, techniques, and methodologies that have emerged since then may invalidate or confirm the claim. We present an empirical investigation which goal is to confirm or reject the claim, based on interaction data which captures the user interface activities of developers. We use interaction data to empirically quantify the distribution of different developer activities during software development: In particular, we focus on estimating the role of program comprehension. In addition, we investigate if and how different developers and session types influence the duration of such activities. We analyze interaction data from two different contexts: One comes from the ECLIPSE IDE on Java source code development, while the other comes from the PHARO IDE on Smalltalk source code development. We found evidence that code navigation and editing occupies only a small fraction of the time of developers, while the vast majority of the time is spent on reading &amp; understanding source code. In essence, the importance of program comprehension was significantly underestimated by previous research. © 2014 IEEE.},
document_type={Conference Paper},
source={Scopus},
}

@ARTICLE{Bergel201366,
author={Bergel, A. and Bettini, L.},
title={Generic Programming in Pharo},
journal={Communications in Computer and Information Science},
year={2013},
volume={411 CCIS},
pages={66-79},
doi={10.1007/978-3-642-45404-2_5},
note={cited By 2},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84904762917&doi=10.1007%2f978-3-642-45404-2_5&partnerID=40&md5=0984edea5fb3cfb6883e41b2a75dc305},
abstract={Dynamically typed object-oriented languages have been left out of the scope of generic programming: in a dynamically typed setting, the need for generic programming has been less prominent since no restriction applies over the kind of elements a collection may contain. However, when creating an object, the class name is hardcoded in the program, and this makes the object instantiation process hard to abstract from. In this paper, we describe our implementation of generic programming in Pharo, a Smalltalk dialect, showing how programmers can benefit from generic programming even in a dynamically typed language. Furthermore, we enhance the expressiveness of generic programming with reverse generics, a mechanism for automatically deriving new generic code starting from existing non-generic one. As a case study, we show how we used generics and reverse generics in Pharo to reuse unit test cases and to identify a number of bugs and anomalies in the stream class hierarchy. © Springer-Verlag Berlin Heidelberg 2013.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Robbes2012,
author={Robbes, R. and Lungu, M. and Röthlisberger, D.},
title={How do developers react to API deprecation? The case of a smalltalk ecosystem},
journal={Proceedings of the ACM SIGSOFT 20th International Symposium on the Foundations of Software Engineering, FSE 2012},
year={2012},
doi={10.1145/2393596.2393662},
note={cited By 58},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84871299619&doi=10.1145%2f2393596.2393662&partnerID=40&md5=617e77a9d9e4647d862fc7df559e914d},
abstract={When the Application Programming Interface (API) of a framework or library changes, its clients must be adapted. This change propagation - known as a ripple effect - is a problem that has garnered interest: several approaches have been proposed in the literature to react to these changes. Although studies of ripple effects exist at the single system level, no study has been performed on the actual extent and impact of these API changes in practice, on an entire software ecosystem associated with a community of developers. This paper reports on an empirical study of API deprecations that led to ripple effects across an entire ecosystem. Our case study subject is the development community gravitating around the Squeak and Pharo software ecosystems: seven years of evolution, more than 3,000 contributors, and more than 2,600 distinct systems. We analyzed 577 methods and 186 classes that were deprecated, and answer research questions regarding the frequency, magnitude, duration, adaptation, and consistency of the ripple effects triggered by API changes. © 2012 ACM.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Teruel2012,
author={Teruel, C. and Ducasse, S. and Denker, M.},
title={Toward a modularization of Pharo: Analysis of the design space for a new module system},
journal={IC 2012 - 23es Journees Francophones d'Ingenierie des Connaissances},
year={2012},
page_count={8},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84875674332&partnerID=40&md5=a98561f198fae676b5527f680f2393d9},
abstract={Smalltalk is a reflective object-oriented programming language. Over the years, it has influenced many other programming languages and evolved into many variants. However, it does not offer the notion of namespace or module. Because all classes and global variables are visible from the whole system, numerous dependencies may be introduced and lead to a monolithic system. As a descendant of Smalltalk, Pharo should provide a language construct conceived with modularity in mind. Besides, transforming Pharo into a modular system it not an easy task: in order to allow the migration, the modular construct must support local class extensions and circular dependencies. Moreover, the design space is large: not only do this construct have to define the semantics of local class extensions and dependency resolution, but it should also do the same with visibility and module parametrization. In this context, this article presents an analysis of the design space through three design axis: local class extensions, dependency resolution and module parametri-zation.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Bergel2012363,
author={Bergel, A. and Bettini, L.},
title={Generics and reverse generics for Pharo},
journal={ICSOFT 2012 - Proceedings of the 7th International Conference on Software Paradigm Trends},
year={2012},
pages={363-372},
note={cited By 3},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84868695534&partnerID=40&md5=4e83645c2636e287392305ba957de48e},
abstract={Generic programming is a mechanism for re-using code by abstracting specific types used in classes and programs. In this paper, we present a mechanism for adding generic programming in dynamically typed languages, showing how programmers can benefit from generic programming. Furthermore, we enhance the expressiveness of generic programming with reverse generics, a mechanism for automatically deriving new generic code starting from existing non-generic one. We implemented generics and reverse generics in Pharo Smalltalk, and we successfully used them to solve a problem of reusing unit test cases. This helped us to identify a number of bugs and anomalies in the stream class hierarchy.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Fabry201231,
author={Fabry, J.},
title={PHANtom: An aspect language for Pharo Smalltalk},
journal={AOSD'12 Companion - Proceedings of the 11th Annual International Conference on Aspect Oriented Software Development},
year={2012},
pages={31-32},
doi={10.1145/2162110.2162130},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84860439215&doi=10.1145%2f2162110.2162130&partnerID=40&md5=75d2798c1b778a1aad7ecdbda2d1d0fe},
abstract={Aspect languages for Smalltalk have not kept up with advances in aspect language research. Arguably the only well-known aspect language for Smalltalk is AspectS. It is a ground-breaking contribution, especially regarding dynamic aspects, yet it lacks amenities which aspect language users have come to rely on, e.g. the use of patterns in pointcuts and the ability to declare aspect precedence. Alternative aspect languages for Smalltalk are effectively absent. As a result, currently Smalltalk lacks a modern and powerful aspect language. To address this deficit, we elected to design and build PHANtom: a modern aspect language for Pharo Smalltalk. PHANtom is designed to be an aspect language in the spirit of Smalltalk: dynamic, simple and powerful. PHANtom is a modern aspect language because it incorporates what we consider to be the best features of languages that precede it, includes recent research results in aspect interactions and reentrancy control, and is designed from the onset to be optimized and compiled where possible. This demo presents PHANtom by first providing an introduction to the language, detailing its philosophy and fundamental features. It second discusses the salient features of the language by demonstrating the use of PHANtom in an example application. © 2012 ACM.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{NoAuthor2012,
title={AOSD'12 Companion - Proceedings of the 11th Annual International Conference on Aspect Oriented Software Development},
journal={AOSD'12 Companion - Proceedings of the 11th Annual International Conference on Aspect Oriented Software Development},
year={2012},
page_count={44},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84860447638&partnerID=40&md5=434f147a4a721d785883108ba69a0bc6},
abstract={The proceedings contain 11 papers. The topics discussed include: what to do when things go wrong: recovery in complex (computer) systems; objects of the people, by the people, and for the people; aspects as latent topics; implementing language-based virtual machines; a unified formal model for service oriented architecture to enforce security contracts; compositional verification of events and aspects; membranes for AOP: from vision to practice; an aspect-oriented framework for development of dynamic content; tearing down the multicore barrier for web applications; adding high-level concurrency to EScala; a scalable and accurate approach based on count matrix for detecting code clones; Emergo: a tool for improving maintainability of preprocessor-based product lines; experiments with the LARA aspect-oriented approach; and PHANtom: an aspect language for pharo smalltalk.},
document_type={Conference Review},
source={Scopus},
}

@ARTICLE{Bergel201216,
author={Bergel, A. and Bañados, F. and Robbes, R. and Röthlisberger, D.},
title={Spy: A flexible code profiling framework},
journal={Computer Languages, Systems and Structures},
year={2012},
volume={38},
number={1},
pages={16-28},
doi={10.1016/j.cl.2011.10.002},
note={cited By 11},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-82455203884&doi=10.1016%2fj.cl.2011.10.002&partnerID=40&md5=b9fc9037c6798abe63367ddfec1f64ca},
abstract={Code profiling is an essential activity to increase software quality. It is commonly employed in a wide variety of tasks, such as supporting program comprehension, determining execution bottlenecks, and assessing code coverage by unit tests. Spy is an innovative framework to easily build profilers and visualize profiling information. The profiling information is obtained by inserting dedicated code before or after method execution. The gathered profiling information is structured in line with the application structure in terms of packages, classes, and methods. Spy has been instantiated on four occasions so far. We created profilers dedicated to test coverage, time execution, type feedback, and profiling evolution across version. We also integrated Spy in the Pharo IDE. Spy has been implemented in the Pharo Smalltalk programming language and is available under the MIT license. © 2011 Elsevier Ltd. All rights reserved.},
document_type={Article},
source={Scopus},
}

@ARTICLE{MartinezPeck20121,
author={Martinez Peck, M. and Bouraqadi, N. and Ducasse, S. and Fabresse, L.},
title={Object swapping challenges: An evaluation of imageSegment},
journal={Computer Languages, Systems and Structures},
year={2012},
volume={38},
number={1},
pages={1-15},
doi={10.1016/j.cl.2011.10.001},
note={cited By 2},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-82455217208&doi=10.1016%2fj.cl.2011.10.001&partnerID=40&md5=fa8f5b5c2ef8fa2a299116646bbd1c6e},
abstract={In object-oriented systems, runtime memory is composed of an object graph in which objects refer to other objects. This graph of objects evolves while the system is running. Graph exporting and swapping are two important object graph operations. Exporting refers to copying the graph to some other memory so that it can be loaded by another system. Swapping refers to moving the graph to a secondary memory (e.g., a hard disk) to temporary release part of the primary memory (e.g., RAM). Exporting and swapping are achieved in different ways and the speed in the presence of large object graphs is critical. Nevertheless, most of the existing solutions do not address well this issue. Another challenge is to deal with common situations where objects outside the exported/swapped graph point to objects inside the graph. To correctly load back an exported subgraph, it is necessary to compute and export extra information that is not explicit in the object subgraph. This extra information is needed because certain objects may require to be reinitialized or recreated, to run specific code before or after the loading, to be updated to a new class definition, etc. In this paper, we present all general problems to our knowledge about object exporting and swapping. As a case of study, we present an analysis of ImageSegment, a fast solution to export and swap object graphs, developed by Ingalls. ImageSegment addresses the speed problems in an efficient way, as shown by the results of several benchmarks we have conducted using Pharo Smalltalk. However, ImageSegment is not a panacea since it still has other problem that hampers its general use. © 2011 Elsevier Ltd. All rights reserved.},
document_type={Article},
source={Scopus},
}

@CONFERENCE{Fabry2011,
author={Fabry, J. and Galdames, D.},
title={PHANtom: A modern aspect language for Pharo Smalltalk},
journal={Proceedings of the International Workshop on Smalltalk Technologies, IWST'11},
year={2011},
doi={10.1145/2166929.2166939},
art_number={10},
note={cited By 5},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84860455749&doi=10.1145%2f2166929.2166939&partnerID=40&md5=360379e62d700da0b5c62d8ba47064c2},
abstract={In the context of our research on Aspect-Oriented Programming, we have a need for a modern and powerful aspect language for Smalltalk. Current aspect languages for Smalltalk however fall short on various points. To address this deficit, we elected to design and build PHANtom: a modern aspect language for Pharo Smalltalk. PHANtom is designed to be an aspect language in the spirit of Smalltalk: dynamic, simple and powerful. PHANtom is a modern aspect language because it incorporates the best features of languages that precede it, includes recent research results in aspect interactions and reentrancy control, and is designed from the onset to be optimized and compiled where possible. In this paper we present the language and outline salient points of its current implementation. Copyright © 2011 ACM.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{NoAuthor2011,
title={Proceedings of the International Workshop on Smalltalk Technologies, IWST'11},
journal={Proceedings of the International Workshop on Smalltalk Technologies, IWST'11},
year={2011},
page_count={112},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84860634332&partnerID=40&md5=5af5bd2c9f120a38842afc978d5cb928},
abstract={The proceedings contain 12 papers. The topics discussed include: clustered serialization with fuel; using first-class contexts to realize dynamic software updates; a smalltalk implementation of exil, a component-based programming language; Klotz: an agile 3D visualization engine; a programming environment supporting a prototype-based introduction to OOP; memoization aspects: a case study; MDE-based FPGA physical design; efficient proxies in smalltalk; challenges to support automated random testing for dynamically typed languages; PHANtom: a modern aspect language for pharo Smalltalk; talents: dynamically composable units of reuse; and towards structural decomposition of reflection with mirrors.},
document_type={Conference Review},
source={Scopus},
}

@CONFERENCE{Dias2011,
author={Dias, M. and Peck, M.M. and Ducasse, S. and Arévalo, G.},
title={Clustered serialization with fuel},
journal={Proceedings of the International Workshop on Smalltalk Technologies, IWST'11},
year={2011},
doi={10.1145/2166929.2166930},
art_number={1},
note={cited By 3},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84860638316&doi=10.1145%2f2166929.2166930&partnerID=40&md5=ecadaf30bdfca84e82423d82d768e464},
abstract={Serializing object graphs is an important activity since objects should be stored and reloaded on different environments. There is a plethora of frameworks to serialize objects based on recursive parsing of the object graphs. However such approaches are often too slow. Most approaches are limited in their provided features. For example, several serializers do not support class shape changes, global references, transient references or hooks to execute something before or after being stored or loaded. Moreover, to be faster, some serializers are not written taking into account the object-oriented paradigm and they are sometimes even implemented in the Virtual Machine hampering code portability. VM-based serializers such as ImageSegment are difficult to understand, maintain, and fix. For the final user, it means a serializer which is difficult to customize, adapt or extend to his own needs. In this paper we present a general purpose object graph serializer based on a pickling format and algorithm. We implement and validate this approach in the Pharo Smalltalk environment. We demonstrate that we can build a really fast serializer without specific VM support, with a clean objectoriented design, and providing most possible required features for a serializer. We show that our approach is faster that traditional serializers and compare favorably with ImageSegment as soon as serialized objects are not in isolation. Copyright © 2011 ACM.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Araya20111140,
author={Araya, V.P.},
title={Test blueprint: An effective visual support for test coverage},
journal={Proceedings - International Conference on Software Engineering},
year={2011},
pages={1140-1142},
doi={10.1145/1985793.1986022},
note={cited By 6},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-79959898722&doi=10.1145%2f1985793.1986022&partnerID=40&md5=45ffeec37ac48510aa4cd2a1e15fbfb0},
abstract={Test coverage is about assessing the relevance of unit tests against the tested application. It is widely acknowledged that a software with a "good" test coverage is more robust against unanticipated execution, thus lowering the maintenance cost. However, insuring a coverage of a good quality is challenging, especially since most of the available test coverage tools do not discriminate software components that require a "strong" coverage from the components that require less attention from the unit tests. Hapao is an innovative test covepage tool, implemented in the Pharo Smalltalk programming language. It employs an effective and intuitive graphical representation to visually assess the quality of the coverage. A combination of appropriate metrics and relations visually shapes methods and classes, which indicates to the programmer whether more effort on testing is required. This paper presents the essence of Hapao using a real world case study. © 2011 ACM.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Röthlisberger200958,
author={Röthlisberger, D. and Nierstrasz, O. and Bergel, A. and Ducasse, S.},
title={Tackling software navigation issues of the Smalltalk IDE},
journal={Proceedings of the International Workshop on Smalltalk Technologies 2009, IWST'09 - ESUG 2009 Smalltalk Joint Event},
year={2009},
pages={58-67},
doi={10.1145/1735935.1735945},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-77954508164&doi=10.1145%2f1735935.1735945&partnerID=40&md5=eb77148fed454ea1da70d08e509a3791},
abstract={The IDE used in most Smalltalk dialects, including Pharo, Squeak and Cincom Smalltalk, did not evolve significantly over the last years, if not to say decades. For other languages, for instance Java, the available IDEs made tremendous progress as Eclipse and Net-Beans illustrate. While the Smalltalk IDE served as an exemplar for many years, other IDEs caught up or even overtook the erstwhile leader in terms of feature-richness, usability and code navigation facilities. In this paper we first analyze the difficulty of software navigation in the Smalltalk IDE and second illustrate with concrete examples the features we added to the Smalltalk IDE to fill the gap to modern IDEs and to provide novel, improved means to navigate source space. We show that thanks to the agility and dynamics of Smalltalk, we are able to extend and enhance with reasonable effort the Smalltalk IDE to better support software navigation, program comprehension, and software maintenance in general. One such support is the integration of dynamic information into the static source views we are familiar with. Other means include easing the access to static information (for instance by better arranging important packages) or helping developers locating artifacts of interest. Copyright 2009 ACM.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Olivero200918,
author={Olivero, F. and Lanza, M. and Robbes, R.},
title={Lumière: A novel framework for rendering 3D graphics in Smalltalk},
journal={Proceedings of the International Workshop on Smalltalk Technologies 2009, IWST'09 - ESUG 2009 Smalltalk Joint Event},
year={2009},
pages={18-27},
doi={10.1145/1735935.1735940},
note={cited By 2},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-77954473686&doi=10.1145%2f1735935.1735940&partnerID=40&md5=4902116aa37ef935941524a4fa0fcf6b},
abstract={To render 3D graphics there is a number of different frameworks written in Smalltalk. While most of them provide powerful facilities, many of them are outdated, abandoned, undocumented or heavyweight. In this paper we present Lumière, a novel lightweight framework for rendering 3D graphics using OpenGL based on a stage metaphor. Lumière is implemented using the Pharo IDE. In its current state it supports basic and composite shapes to populate 3D scenes, features a camera, and a lighting model. We illustrate the usage of Lumière with Gaucho, an environment for visual programming we are currently building. Copyright 2009 ACM.},
document_type={Conference Paper},
source={Scopus},
}

@ARTICLE{Ducasse2009252,
author={Ducasse, S. and Pollet, D. and Bergel, A. and Cassou, D.},
title={Reusing and composing tests with traits},
journal={Lecture Notes in Business Information Processing},
year={2009},
volume={33 LNBIP},
pages={252-271},
doi={10.1007/978-3-642-02571-6_15},
note={cited By 4},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-68949110249&doi=10.1007%2f978-3-642-02571-6_15&partnerID=40&md5=feb6fd5cecaa145282fb3b492a2c1c66},
abstract={Single inheritance often forces developers to duplicate code and logic. This widely recognized situation affects both business code and tests. In a large and complex application whose classes implement many groups of methods (protocols), duplication may also follow the application's idiosyncrasies, making it difficult to specify, maintain, and reuse tests. The research questions we faced are (i) how can we reuse test specifications across and within complex inheritance hierarchies, especially in presence of orthogonal protocols; (ii) how can we test interface behavior in a modular way; (iii) how far can we reuse and parametrize composable tests. In this paper, we compose tests out of separately specified behavioral units of reuse -traits. We propose test traits, where: (i) specific test cases are composed from independent specifications; (ii) executable behavior specifications may be reused orthogonally to the class hierarchy under test; (iii) test fixtures are external to the test specifications, thus are easier to specialize. Traits have been successfully applied to test two large and critical class libraries in Pharo, a new Smalltalk dialect based on Squeak, but are applicable to other languages with traits. © 2009 Springer Berlin Heidelberg.},
document_type={Conference Paper},
source={Scopus},
}
