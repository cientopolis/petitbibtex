@INPROCEEDINGS{7476650,
author={B. {Spasojevic} and M. {Lungu} and O. {Nierstrasz}},
booktitle={2016 IEEE 23rd International Conference on Software Analysis,
Evolution, and Reengineering (SANER)},
title={A Case Study on Type Hints in Method Argument Names in Pharo
Smalltalk Projects},
year={2016},
volume={1},
number={},
pages={283-292},
abstract={A common practice when writing Smalltalk source code is to
name method arguments in a way that hints at their expected type (i.e.,
aString, anInteger, aDictionary). This practice makes code more
readable, but the prevalence of this practice is unknown, thus its
reliability is questionable. Tools such as the auto complete feature in
the Pharo Smalltalk code editor rely on these hints to improve the
developer experience. The default algorithm used in Pharo to extract
type information from these hints succeeds in extracting a type in
slightly over 36% of method arguments taken from 114 Pharo projects. In
this paper we present the results of analyzing the failing method
argument names, and provide several simple heuristics that can increase
the rate of success to slightly over 50%. We also present a case study
on the relation between type hints and run-time types of method
arguments that shows that type hints, in a great majority of cases,
reflect run-time types.},
keywords={project management;Smalltalk;source code (software);type
hints;method argument names;Pharo Smalltalk projects;Smalltalk source
code;aString;anInteger;aDictionary;Pharo Smalltalk code editor;run-time
type method;Data mining;Inspection;Electronic mail;Feature
extraction;Browsers;Manuals;Java},
doi={10.1109/SANER.2016.41},
ISSN={},
month={March},}
@INPROCEEDINGS{6032614,
author={V. P. {Araya}},
booktitle={2011 33rd International Conference on Software Engineering
(ICSE)},
title={Test blueprint: an effective visual support for test coverage},
year={2011},
volume={},
number={},
pages={1140-1142},
abstract={Test coverage is about assessing the relevance of unit tests
against the tested application. It is widely acknowledged that a
software with a "good" test coverage is more robust against
unanticipated execution, thus lowering the maintenance cost. However,
insuring a coverage of a good quality is challenging, especially since
most of the available test coverage tools do not discriminate software
components that require a "strong" coverage from the components that
require less attention from the unit tests. HAPAO is an innovative test
covepage tool, implemented in the Pharo Smalltalk programming language.
It employs an effective and intuitive graphical representation to
visually assess the quality of the coverage. A combination of
appropriate metrics and relations visually shapes methods and classes,
which indicates to the programmer whether more effort on testing is
required. This paper presents the essence of HAPAO using a real world
case study.},
keywords={object-oriented languages;object-oriented programming;program
testing;program visualisation;software cost estimation;software
maintenance;software metrics;software quality;software tools;test
blueprint;test coverage visual support;unit tests;software test
coverage;software maintenance cost;software quality;software
component;HAPAO test coverage tool;Pharo Smalltalk programming
language;graphical representation;software
metrics;Software;Testing;Complexity
theory;Visualization;Measurement;Context;Computer
languages;coverage;pharo;testing;visualization},
doi={10.1145/1985793.1986022},
ISSN={1558-1225},
month={May},}
@INPROCEEDINGS{5328797,
author={J. {Laval} and S. {Denier} and S. {Ducasse} and A. {Bergel}},
booktitle={2009 16th Working Conference on Reverse Engineering},
title={Identifying Cycle Causes with Enriched Dependency Structural
Matrix},
year={2009},
volume={},
number={},
pages={113-122},
abstract={Dependency structure matrix (DSM) has been successfully
applied to identify software dependencies among packages and subsystems.
A number of algorithms were proposed to compute the matrix so that it
highlights patterns and problematic dependencies between subsystems.
However, existing DSM implementations often miss important information
to fully support reengineering effort. For example, they do not clearly
qualify and quantify problematic relationships, information which is
crucial to support remediation tasks.In this paper we present enriched
DSM (eDSM) where cells are enriched with contextual information about
(i) the type of dependencies (inheritance, class reference...), (ii) the
proportion of referencing entities, (iii) the proportion of referenced
entities. We distinguish independent cycles and stress potentially
simple fixes for cycles using coloring information. This work is
language independent and has been implemented on top of the Moose
reengineering environment. It has been applied to non-trivial case
studies among which ArgoUML, and Morphic the UI framework available in
two open-source Smalltalks, Squeak and Pharo. Solution to problems
identified by eDSM have been performed and retrofitted in Pharo main
distribution.},
keywords={Smalltalk;software packages;systems re-engineering;Unified
Modeling Language;cycle causes;enriched dependency structural
matrix;software dependency;packages;subsystems;reengineering;coloring
information;Moose reengineering environment;ArgoUML;Morphic;UI
framework;open-source Smalltalks;Squeak;Pharo;eDSM;Packaging;Open source
software;Visualization;Application software;Software packages;Reverse
engineering;Europe;Stress;Computer architecture;Linux;software
visualization;reengineering;dependency structural
matrix;package;dependency},
doi={10.1109/WCRE.2009.11},
ISSN={1095-1350},
month={Oct},}
@INPROCEEDINGS{6958415,
author={R. {Minelli} and A. {Mocci} and M. {Lanza} and T. {Kobayashi}},
booktitle={2014 14th International Conference on Quality Software},
title={Quantifying Program Comprehension with Interaction Data},
year={2014},
volume={},
number={},
pages={276-285},
abstract={It is common knowledge that program comprehension takes up a
substantial part of software development. This "urban legend" is based
on work that dates back decades, which throws up the question whether
the advances in software development tools, techniques, and
methodologies that have emerged since then may invalidate or confirm the
claim. We present an empirical investigation which goal is to confirm or
reject the claim, based on interaction data which captures the user
interface activities of developers. We use interaction data to
empirically quantify the distribution of different developer activities
during software development: In particular, we focus on estimating the
role of program comprehension. In addition, we investigate if and how
different developers and session types influence the duration of such
activities. We analyze interaction data from two different contexts: One
comes from the ECLIPSE IDE on Java source code development, while the
other comes from the PHARO IDE on Smalltalk source code development. We
found evidence that code navigation and editing occupies only a small
fraction of the time of developers, while the vast majority of the time
is spent on reading & understanding source code. In essence, the
importance of program comprehension was significantly underestimated by
previous research.},
keywords={human computer interaction;Java;Smalltalk;software
engineering;source code (software);user interfaces;program
comprehension;interaction data;software development tools;software
development techniques;software developer user interface
activities;ECLIPSE IDE;Java source code development;PHARO IDE;Smalltalk
source code development;code navigation;code
editing;Navigation;History;Java;Inspection;Software;Browsers;Maintenance
engineering;Program Comprehension;Program
Understanding;Quantification;Interaction data;IDE},
doi={10.1109/QSIC.2014.11},
ISSN={1550-6002},
month={Oct},}
@INPROCEEDINGS{7816485,
author={A. A. {Sawant} and R. {Robbes} and A. {Bacchelli}},
booktitle={2016 IEEE International Conference on Software Maintenance
and Evolution (ICSME)},
title={On the Reaction to Deprecation of 25,357 Clients of 4+1 Popular
Java APIs},
year={2016},
volume={},
number={},
pages={400-410},
abstract={Application Programming Interfaces (APIs) are a tremendous
resource-that is, when they are stable. Several studies have shown that
this is unfortunately not the case. Of those, a large-scale study of API
changes in the Pharo Smalltalk ecosystem documented several findings
about API deprecations and their impact on API clients. We conduct a
partial replication of this study, considering more than 25,000 clients
of five popular Java APIs on GitHub. This work addresses several
shortcomings of the previous study, namely: a study of several distinct
API clients in a popular, statically-typed language, with more accurate
version information. We compare and contrast our findings with the
previous study and highlight new ones, particularly on the API client
update practices and the startling similarities between reaction
behavior in Smalltalk and Java.},
keywords={Java;public domain software;popular Java APIs;application
programming interfaces;Pharo Smalltalk
ecosystem;GitHub;Java;Ecosystems;History;Programming;Software;Libraries;Documentation;API;deprecation;mining
software repositories},
doi={10.1109/ICSME.2016.64},
ISSN={},
month={Oct},}
@INPROCEEDINGS{7961506,
author={N. {Milojkovic} and M. {Ghafari} and O. {Nierstrasz}},
booktitle={2017 IEEE/ACM 25th International Conference on Program
Comprehension (ICPC)},
title={Exploiting Type Hints in Method Argument Names to Improve
Lightweight Type Inference},
year={2017},
volume={},
number={},
pages={77-87},
abstract={The lack of static type information is one of the main
obstacles to program comprehension in dynamically-typed languages. While
static type inference algorithms try to remedy this problem, they
usually suffer from the problem of false positives or false negatives.
In order to partially compensate for the lack of static type
information, a common practice in dynamically-typed languages is to name
or annotate method arguments in such a way that they reveal their
expected type, e.g., aString, anInt, or string: String. Recent studies
confirmed that these type annotations are indeed frequently used by
developers in dynamically-typed languages. We propose a lightweight
heuristic that uses these hints from method argument names to augment
the performance of a static type inference algorithm. The evaluation
through a proof-of-concept prototype implemented in Pharo Smalltalk
shows that the augmented algorithm outperforms the basic algorithm, and
correctly infers types for 81% more method arguments.},
keywords={reasoning about programs;source code (software);type
theory;static type information;program comprehension;dynamically-typed
languages;static type inference algorithms;false negatives;false
positives;lightweight heuristic;proof-of-concept prototype;Pharo
Smalltalk;augmented algorithm;Inference algorithms;Heuristic
algorithms;Software;Algorithm design and analysis;Software
algorithms;Prototypes;Cognition;type-inference;dynamically-typed
languages;heuristic;type hints},
doi={10.1109/ICPC.2017.33},
ISSN={},
month={May},}
@INPROCEEDINGS{7332511,
author={P. {Oliveira} and M. T. {Valente} and A. {Bergel} and A.
{Serebrenik}},
booktitle={2015 IEEE International Conference on Software Maintenance
and Evolution (ICSME)},
title={Validating metric thresholds with developers: An early result},
year={2015},
volume={},
number={},
pages={546-550},
abstract={Thresholds are essential for promoting source code metrics as
an effective instrument to control the internal quality of software
applications. However, little is known about the relation between
software quality as identified by metric thresholds and as perceived by
real developers. In this paper, we report the first results of a study
designed to validate a technique that extracts relative metric
thresholds from benchmark data. We use this technique to extract
thresholds from a benchmark of 79 Pharo/Smalltalk applications, which
are validated with five experts and 25 developers. Our preliminary
results indicate that good quality applications - as cited by experts -
respect metric thresholds. In contrast, we observed that noncompliant
applications are not largely viewed as requiring more effort to maintain
than other applications.},
keywords={program verification;software metrics;software quality;source
code (software);source code metrics;software quality;Pharo-Smalltalk
application;software measurement;Zinc;Benchmark testing;Software
quality;Software measurement;Ecosystems;Source Code Metrics;Relative
Thresholds;Software Quality;Software Measurement;Empirical Studies},
doi={10.1109/ICSM.2015.7332511},
ISSN={},
month={Sep.},}
